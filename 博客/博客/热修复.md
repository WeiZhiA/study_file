热修复

# 热修复现状

## 主流热修复
方案名称 |  方案开发公司 |  开发时间 |  Github星评
---|---|---|---
Robust |  美团 |  2016年 |  54
Andfix |  阿里 |  2015年 |  4994
Nuwa |  个人开发者（dex文件补丁） |  2015年 |  2588
Dexposed |  不考虑，需要root权限 |   |  
Amigo |  饿了么（apk补丁） |  2016年 |  1031
Tinker |  微信(apk补丁) |  2016年 |  7891
RocooFix |  Nuwa改进版 |  2016年 |  1299

## 主要热修复对比
方案对比 |  Sophix |  Tinker |  Amigo
---|---|---|---
DEX修复 |  同时支持即时生效和冷启动修复 |  冷启动修复 |  冷启动修复
资源更新 |  差量包，不用合成 |  差量包，需要合成 |  全量包，不用合成
SO库更新 |  插桩实现，开发透明 |  替换接口，开发不透明 |  插桩实现，开发透明
性能损耗 |  低，仅冷启动情况下有些损耗 |  高，有合成操作 |  低，全量替换
四大组件 |  不能新增 |  不能新增 |  能新增
生成补丁 |  直接选择已经编好的新旧包在本地生成 |  编译新包时设置基线包 |  上传完整新包到服务端
补丁大小 |  小 |  小 |  大
接入成本 |  傻瓜式接入 |  复杂 |  一般
Android版本 |  全部支持 |  全部支持 |  全部支持
安全机制 |  加密传输及签名校验 |  加密传输及签名校验 |  加密传输及签名校验
服务端支持 |  支持服务端控制 |  支持服务端控制 |  支持服务端控制

一种是阿里系的底层替换方案，另一种是腾讯系的类加载方案。
这两类方案各有优劣：
(1)底层替换方案限制颇多，但时效性最好，加载轻快，立即见效。
(2)类加载方案时效性差，需要重新冷启动才能见效，但修复范围广，限制少。

# 1.微信tinker
(1)生成差量包，
(2)通过一定算法，将dex和差量包合并成新的dex包，替换旧的dex包
(3)重启加载新的dex文件

# 2.阿里云Sophix
(1)底层替换
在已经加载了的类中直接在native层替换掉原有方法，是在原来类的基础上进行修改的。不需要重启。（阿里Andfix）
优点：补丁小，加载快，实时生效无需重新启动app，并且具有着完美的设备兼容性
缺点：依赖底层代码，一旦厂商修改源码，就不能生效，从而通用性差；只能修改方法，不能增加或删除类或属性。

(2)类加载方案
类加载器：启动类加载器；扩展类加载器；应用程序类加载器
原理：双亲委托，保证多个类加载器，一个类只会被类加载器

(1)首先判断该Class是否已经加载
(2)如果没有则不是自身去查找而是委托给父加载器进行查找，这样依次的进行递归，直到委托到最顶层的Bootstrap ClassLoader
(3)如果Bootstrap ClassLoader找到了该Class，就会直接返回
(4)如果没找到，则继续依次向下查找，如果还没找到则最后会交由自身去查找


已经加载过的类不会重复被加载到内存中。

优点：
缺点：只能重启，才能加载补丁中的新类


## 总结
在补丁生成阶段，补丁工具会根据实际代码变动情况进行自动选择，针对小修改，在底层替换方案限制范围内的，就直接采用底层替换修复吗，这样可以做到代码修复即时生效。而对于代码修改超出底层替换限制的，会使用类加载替换，这样虽然及时性没那么好，但总归可以达到热修复的目的。


# 1.QQ空间超级补丁技术
已经加载的类不会再次加载

(1)可以看出是通过获取到当前应用的Classloader
(2)通过反射调用pathList的dexElements方法把patch.dex转化为Element[]
(3)两个Element[]进行合并，把patch.dex放到最前面去
(4)加载Element[]，达到修复目的

## 不足
(1)不会及时生效，必须通过重启才能生效。
(2)时严重，会增加启动时间，导致ANR的概率明显增大